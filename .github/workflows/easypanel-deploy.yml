```yaml
name: Synthetica Self-Healing CI/CD Pipeline

# 1. Triggers
on:
  # Manual trigger with input required for the recursive healing loop
  workflow_dispatch:
    inputs:
      attempt_count:
        description: 'Current attempt number for self-healing loop'
        required: true
        default: '1'
        type: string
  
  # Standard push trigger (starts the initial attempt)
  push:
    branches:
      - main
      - develop

  # 4. Continuous Monitoring (Periodic Self-Check)
  schedule:
    # Runs every day at 03:00 UTC
    - cron: '0 3 * * *'

env:
  MAX_ATTEMPTS: 3
  STAGING_ENV: staging
  PROD_ENV: production
  # Determines the current attempt number, prioritizing workflow_dispatch input
  CURRENT_ATTEMPT: ${{ github.event.inputs.attempt_count || 1 }}

jobs:

  # =======================================================
  # JOB 1: Pipeline Execution (Build, Test, Deploy)
  # This job contains the core logic and runs iteratively via self-dispatching.
  # =======================================================
  main_pipeline:
    runs-on: ubuntu-latest
    
    # Use environment definitions for protection rules in GitHub
    environment: ${{ (github.ref == 'refs/heads/main') && env.PROD_ENV || env.STAGING_ENV }}
    
    # Only run the main job if the trigger is PUSH or MANUAL (not schedule)
    if: github.event_name != 'schedule'
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Setup Environment (Example: Node.js)
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Report Current Healing Attempt
        run: echo "Starting pipeline execution attempt #${{ env.CURRENT_ATTEMPT }} of ${{ env.MAX_ATTEMPTS }}."

      # --- Build Stage ---
      - name: 1. Build Application
        id: build_app
        run: |
          echo "Building application artifacts..."
          # Replace with actual build commands (e.g., npm run build, docker build)
          npm install
          npm run build

      # --- Test Stage (Simulated Failure Point 1) ---
      - name: 2. Run Unit and Integration Tests
        id: run_tests
        run: |
          echo "Running tests..."
          # Replace with actual test commands (e.g., npm test)
          
      # --- Deploy Staging Stage ---
      - name: 3. Deploy to Staging Environment
        id: deploy_staging
        # Run only if the previous critical steps succeeded
        if: success()
        uses: actions/deploy-to-staging@v1 # Placeholder Action
        with:
          environment_url: staging.app.com
          
      # --- Deploy Production Stage (Only run from main branch or successful staging deployment) ---
      - name: 4. Deploy to Production Environment
        id: deploy_production
        # Deploy only if the branch is 'main' and all prior steps succeeded on the initial attempt
        if: github.ref == 'refs/heads/main' && success() && env.CURRENT_ATTEMPT == 1
        uses: actions/deploy-to-prod@v1 # Placeholder Action
        with:
          environment_url: prod.app.com
          
      # =======================================================
      # 5. SELF-HEALING/RETRY LOGIC (Synthetica Automation)
      # This step checks for critical failure and initiates a retry loop.
      # =======================================================
      - name: 5. Synthetica Self-Healing Analysis & Dispatch
        id: self_heal
        # Only execute this step if the pipeline has failed (e.g., build, test, or staging failed) 
        # AND we have not exhausted our maximum number of attempts.
        if: failure() && env.CURRENT_ATTEMPT < env.MAX_ATTEMPTS
        uses: actions/github-script@v6
        with:
          # Required to dispatch a new workflow run
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const maxAttempts = parseInt(process.env.MAX_ATTEMPTS);
            const currentAttempt = parseInt(process.env.CURRENT_ATTEMPT);
            const nextAttempt = currentAttempt + 1;
            
            console.log(`Pipeline failed on attempt ${currentAttempt}.`);

            // --- Simulated Code Alteration Log ---
            console.log(`Synthetica AI: Analyzing failure logs and generating configuration/code adjustments for attempt ${nextAttempt}.`);
            // NOTE: True self-healing (altering code) requires PAT permissions and external logic.
            // This script simulates the decision to retry after 'healing' occurs.

            // --- Dispatch New Workflow Run (Recursive Loop) ---
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'synthetica_ci.yml', # Must match this file's name
              ref: context.ref,
              inputs: {
                attempt_count: nextAttempt.toString()
              }
            });

            console.log(`Healing attempt triggered. Restarting pipeline with attempt #${nextAttempt}.`);
        env:
          MAX_ATTEMPTS: ${{ env.MAX_ATTEMPTS }}
          CURRENT_ATTEMPT: ${{ env.CURRENT_ATTEMPT }}

      # Final step to fail the workflow if the max attempts limit has been reached
      - name: 6. Final Failure Report and Halt
        if: failure() && env.CURRENT_ATTEMPT == env.MAX_ATTEMPTS
        run: |
          echo "ERROR: Synthetica healing failed after ${{ env.MAX_ATTEMPTS }} maximum attempts."
          exit 1
          
  # =======================================================
  # JOB 2: Cleanup
  # =======================================================
  cleanup:
    runs-on: ubuntu-latest
    needs: main_pipeline
    if: always() # Ensure cleanup runs after success, failure, or cancellation
    steps:
      - name: Final Cleanup and Resource Deallocation
        run: |
          echo "Running final cleanup (e.g., removing temp artifacts, reporting status)."
          echo "Cleanup complete."

  # =======================================================
  # JOB 3: Monitoring (Periodic Self-Check)
  # =======================================================
  periodic_check:
    runs-on: ubuntu-latest
    # Only runs when triggered by the 'schedule'
    if: github.event_name == 'schedule'
    steps:
      - name: Perform Periodic Self-Check & Status Update
        run: |
          echo "Running scheduled self-check for application status and new code updates."
          # This step simulates the system checking its deployed status 
          # and re-validating configurations against the latest code base.
          echo "Status check complete. System is healthy."
```
